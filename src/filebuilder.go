package src

import (
	"strconv"
	"strings"
)

type FileBuilder struct {
	namedImports map[string]string // path => named import alias
	types        []*TypeBuilder
}

func NewFileBuilder() *FileBuilder {
	return &FileBuilder{namedImports: map[string]string{}}
}

func (b *FileBuilder) NewType(f func(t *TypeBuilder)) {
	t := NewTypeBuilder(b)
	f(t)
	b.types = append(b.types, t)
}

// Use introduces the given qualifier and performs a named import and returns a string which consists of
// <prefix>.<name> or just the name for universe types.
func (b *FileBuilder) Use(q Qualifier) string {
	// universe scope has just the . and does not need any import
	if strings.HasPrefix(string(q), ".") {
		return string(q[1:])
	}

	if name, has := b.namedImports[q.Path()]; has {
		return name + "." + q.Name()
	}

	for i := 0; i >= 0; i++ {
		nextName := sanitizeName(strings.ToLower(lastName(q.Path())))
		if i > 0 {
			nextName += strconv.Itoa(i)
		}

		if !b.hasImportAlias(nextName) {
			b.namedImports[q.Path()] = nextName
			return nextName + "." + q.Name()
		}
	}

	panic("invalid state")
}

func (b *FileBuilder) hasImportAlias(a string) bool {
	for _, v := range b.namedImports {
		if v == a {
			return true
		}
	}

	return false
}

func (b *FileBuilder) Emit(w Writer) {
	w.Printf("// Code generated by reflectplus. DO NOT EDIT.\n\n")
	w.Printf("package xy\n\n")
	if len(b.namedImports) > 0 {
		w.Printf("import(\n")
		for path, name := range b.namedImports {
			w.Printf("%s \"%s\"\n", name, path)
		}
		w.Printf(")\n")
	}
	for _, t := range b.types {
		t.Emit(w)
	}
}

func lastName(text string) string {
	tokens := strings.Split(text, "/")
	pkgname := text
	if len(tokens) > 0 {
		pkgname = tokens[len(tokens)-1]
	}
	return pkgname
}

func sanitizeName(text string) string {
	sb := &strings.Builder{}
	for _, r := range text {
		if r >= 'a' && r <= 'z' {
			sb.WriteRune(r)
		}
	}

	return sb.String()
}
